### Higher-Order Function

A **higher-order function** is a function that either:

1. Takes one or more functions as arguments.
2. Returns a function as a result.

In other words, it operates on other functions by either accepting them as input or returning them as output.

#### Example in Python:

```python
# Higher-order function that takes another function as argument
def apply_function(func, value):
    return func(value)

# A simple function to be passed to the higher-order function
def square(x):
    return x * x

result = apply_function(square, 5)  # Pass 'square' function as argument
print(result)  # Output: 25
```

In this example, `apply_function` is a higher-order function because it takes the `square` function as an argument and
applies it to a value.

#### Example in TypeScript:

```typescript
// Higher-order function that takes another function as argument
function applyFunction(func: (x: number) => number, value: number): number {
  return func(value);
}

// A simple function to be passed to the higher-order function
const square = (x: number): number => x * x;

const result = applyFunction(square, 5); // Pass 'square' function as argument
console.log(result); // Output: 25
```

In this TypeScript example, `applyFunction` is a higher-order function because it takes a function (`square`) as an argument
and returns the result of calling it on `value`.

---

### Compound Function

A **compound function** is a function that combines multiple functions to create a new function. This typically involves
composing functions, where the output of one function becomes the input to another.

For example, function composition is where you chain multiple functions together.

#### Example in Python (using function composition):

```python
# Function that combines two functions into one
def compose(f, g):
    return lambda x: f(g(x))

# Functions to be composed
def add2(x):
    return x + 2

def multiply3(x):
    return x * 3

# Composing add2 and multiply3 (add2 after multiply3)
result = compose(add2, multiply3)(5)  # First multiply by 3, then add 2
print(result)  # Output: 17 (5 * 3 = 15, 15 + 2 = 17)
```

Here, `compose` is a compound function that takes two functions (`add2` and `multiply3`) and returns a new function that
applies them in a specific order.

#### Example in TypeScript (using function composition):

```typescript
// Function that combines two functions into one
function compose<T>(f: (x: T) => T, g: (x: T) => T): (x: T) => T {
  return (x: T) => f(g(x));
}

// Functions to be composed
const add2 = (x: number): number => x + 2;
const multiply3 = (x: number): number => x * 3;

// Composing add2 and multiply3 (add2 after multiply3)
const result = compose(add2, multiply3)(5); // First multiply by 3, then add 2
console.log(result); // Output: 17 (5 * 3 = 15, 15 + 2 = 17)
```

In this TypeScript example, `compose` is used to create a new function that applies `multiply3` first, then applies `add2` to
the result.

---

### Summary:

- **Higher-order function**: A function that takes another function as an argument or returns a function.
- **Compound function**: A function that combines two or more functions, often by function composition.

Both higher-order functions and compound functions are common in functional programming paradigms and are used extensively in
modern JavaScript/TypeScript and Python for code modularity and reusability.

### Higher-Order Function

A **higher-order function** is a function that does at least one of the following:

1. **Takes one or more functions as arguments**.
2. **Returns a function** as its result.

This is a core concept in functional programming and is supported in both Python and TypeScript.

---

### Compound Function (Function Composition)

A **compound function** (or **function composition**) is when you combine two or more functions to produce a new function.
Typically, the output of one function becomes the input of the next.

Mathematically: `(f ∘ g)(x) = f(g(x))`

---

## Examples in **Python**

### Higher-Order Function

```python
# Example 1: Function that takes another function as argument
def apply_operation(func, x, y):
    return func(x, y)

def add(a, b):
    return a + b

def multiply(a, b):
    return a * b

print(apply_operation(add, 3, 4))       # Output: 7
print(apply_operation(multiply, 3, 4))   # Output: 12

# Example 2: Function that returns a function
def create_multiplier(factor):
    def multiplier(x):
        return x * factor
    return multiplier

double = create_multiplier(2)
triple = create_multiplier(3)

print(double(5))  # Output: 10
print(triple(5))  # Output: 15
```

---

### Compound Function (Composition)

```python
# Manual composition
def add_one(x):
    return x + 1

def square(x):
    return x * x

def compose(f, g):
    return lambda x: f(g(x))

add_one_then_square = compose(square, add_one)
print(add_one_then_square(3))  # (3 + 1)^2 = 16

# Using functools (Python 3.11+ has compose, but here's manual version)
from functools import reduce

def pipe(*functions):
    return lambda x: reduce(lambda acc, f: f(acc), functions, x)

result = pipe(add_one, square, lambda x: x - 10)
print(result(3))  # ((3 + 1)^2) - 10 = 6
```

---

## Examples in **TypeScript**

### Higher-Order Function

```typescript
// Example 1: Function that takes another function
function applyOperation<T>(func: (a: T, b: T) => T, x: T, y: T): T {
  return func(x, y);
}

const add = (a: number, b: number): number => a + b;
const multiply = (a: number, b: number): number => a * b;

console.log(applyOperation(add, 3, 4)); // 7
console.log(applyOperation(multiply, 3, 4)); // 12

// Example 2: Function that returns a function
function createMultiplier(factor: number): (x: number) => number {
  return (x: number) => x * factor;
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15
```

---

### Compound Function (Composition)

```typescript
// Generic compose function
function compose<A, B, C>(f: (b: B) => C, g: (a: A) => B): (a: A) => C {
  return (x: A) => f(g(x));
}

const addOne = (x: number): number => x + 1;
const square = (x: number): number => x * x;

const addOneThenSquare = compose(square, addOne);
console.log(addOneThenSquare(3)); // 16

// Pipe (left-to-right composition)
function pipe<T>(...fns: Array<(arg: T) => T>): (arg: T) => T {
  return (x: T) => fns.reduce((acc, fn) => fn(acc), x);
}

const process = pipe(
  (x: number) => x + 1,
  (x: number) => x * x,
  (x: number) => x - 10
);

console.log(process(3)); // 6
```

---

## Summary Table

| Concept                         | Python Example                | TypeScript Example           |
| ------------------------------- | ----------------------------- | ---------------------------- |
| **Higher-Order (takes func)**   | `apply_operation(add, 3, 4)`  | `applyOperation(add, 3, 4)`  |
| **Higher-Order (returns func)** | `create_multiplier(2)`        | `createMultiplier(2)`        |
| **Compound (Composition)**      | `compose(square, add_one)(3)` | `compose(square, addOne)(3)` |
| **Compound (Pipeline)**         | `pipe(add_one, square)(3)`    | `pipe(addOne, square)(3)`    |

---

Both languages fully support higher-order and compound functions — great for clean, reusable, and functional-style code!
